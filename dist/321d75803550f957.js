const canvas=document.querySelector("canvas.webgl"),scene=new THREE.Scene,canvasContainer=document.querySelector(".canvas"),sizes={width:canvasContainer.offsetWidth,height:canvasContainer.offsetHeight};window.addEventListener("resize",(()=>{sizes.width=window.innerWidth,sizes.height=window.innerHeight,camera.aspect=sizes.width/sizes.height,camera.updateProjectionMatrix(),renderer.setSize(sizes.width,sizes.height),renderer.setPixelRatio(Math.min(window.devicePixelRatio,2))}));const camera=new THREE.PerspectiveCamera(75,sizes.width/sizes.height,.1,100);camera.position.z=15,scene.add(camera);const renderer=new THREE.WebGLRenderer({canvas,antialias:!0});renderer.setSize(sizes.width,sizes.height),renderer.setPixelRatio(Math.min(window.devicePixelRatio,2));const textureLoader=new THREE.TextureLoader,earthUVMap=textureLoader.load("./textures/earth_uv_map.jpg"),sphere=new THREE.Mesh(new THREE.SphereGeometry(5,50,50),new THREE.ShaderMaterial({vertexShader:"\n            varying vec2 vertexUV;\n            varying vec3 vertexNormal;\n\n            void main() \n            {\n                vertexUV = uv;\n                vertexNormal = normalize(normalMatrix * normal);\n                gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );  \n            }",fragmentShader:"\n            uniform sampler2D globeTexture;\n            varying vec2 vertexUV; //[0,0.24]\n            varying vec3 vertexNormal;\n            \n            void main() \n            {\n                float intensity = 1.05 - dot(vertexNormal, vec3(0,0,1));\n                vec3 atmosphere = vec3(0.3,0.6,1) * pow(intensity, 1.5);\n                gl_FragColor = vec4(atmosphere + texture2D(globeTexture, vertexUV).xyz, 1.0);\n            }",uniforms:{globeTexture:{value:earthUVMap}}})),atmosphere=new THREE.Mesh(new THREE.SphereGeometry(5,50,50),new THREE.ShaderMaterial({vertexShader:"\n            varying vec3 vertexNormal;\n\n            void main() \n            {\n                vertexNormal = normalize(normalMatrix * normal);\n                gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );  \n            }",fragmentShader:"\n            varying vec3 vertexNormal; \n\n            void main() \n            {\n                float intensity = pow(0.6 - dot(vertexNormal, vec3(0,0,1.0)),2.0);\n                gl_FragColor = vec4(0.3,0.6,1.0,1.0) * intensity;\n            }",blending:THREE.AdditiveBlending,side:THREE.BackSide}));atmosphere.scale.set(1.2,1.2,1.2);const group=new THREE.Group;group.add(sphere,atmosphere),scene.add(group);const starGeometry=new THREE.BufferGeometry,starMaterial=new THREE.PointsMaterial({color:"#ffffff"}),count=2500,positions=new Float32Array(7500);for(let e=0;e<2500;e+=3){const t=200*(Math.random()-.5),n=200*(Math.random()-.5),r=500*-Math.random();positions[e]=t,positions[e+1]=n,positions[e+2]=r}starGeometry.setAttribute("position",new THREE.BufferAttribute(positions,3));const stars=new THREE.Points(starGeometry,starMaterial);scene.add(stars);const mouse={};window.addEventListener("mousemove",(e=>{mouse.x=e.clientX/sizes.width*2-1,mouse.y=-e.clientY/sizes.height*2+1}));const clock=new THREE.Clock,tick=()=>{const e=clock.getElapsedTime();sphere.rotation.y=.1*e,(mouse.x||mouse.y)&&(gsap.to(group.rotation,{y:.4*mouse.x,duration:2}),gsap.to(group.rotation,{x:.2*mouse.y,duration:2}));const t=Math.cos(e);stars.position.set(t,t,t),renderer.render(scene,camera),window.requestAnimationFrame(tick)};tick();